/* figure.c -- Mid level parse for EDIF */

/* Copyright (C) 1993 -- Data I/O Corporation -- All Rights Reserved.
 *
 * This program is protected under the copyright laws as a published work.
 * It may not be copied, reproduced, further distributed, adaptations
 * made from the same, or used to prepare derivative works, without the
 * prior written consent of the Data I/O Corporation
 *
 * History:
 *    5/05/93 - Included in Version 2.5
 */

#include "stdafx.h"
#include "edifin.h"
#include "mathmac.h"

extern long scale_num, scale_denom;
extern int font_height[];

#define WIDE MAX_WIDTH
#define HIGH MAX_HEIGHT

int text_height, is_visible;
int path_width, border_width;
POINT xy[3];                  /* generated by figure processing */

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static void pointList( int close )
/* if close is TRUE use border_width ( rectangle or polygon ) */
 { POINT firstxy, lastxy;
   int pnts = 0;
   int wid = 0;
   Match( '(' );
   MatchKeyword( K_POINTLIST );
   if ( close && border_width || !close && path_width ) wid = GR_WIDE;
   while ( lookahead == '(' )
    { pointValue( &xy[0] );
      if ( pnts )
         Add_Symbol_Grf( GR_LINE + wid, lastxy, xy[0], lastxy, lastxy );
      else firstxy = xy[0];
      lastxy = xy[0];
      pnts = 1;
    }
   /* decide whether or not to close it off */
   if ( close && pnts && ( firstxy.x != lastxy.x || firstxy.y != lastxy.y ) )
    { Add_Symbol_Grf( GR_LINE + wid, firstxy, lastxy, firstxy, firstxy );
    }
   Match( ')' );
 }

static void path()
 {
   Match( '(' );
   MatchKeyword( K_PATH );
   pointList( 0 );
   if ( lookahead == '(' ) IgnoreForm();           /* ignore property in path */
   Match( ')' );
 }

static void polygon()
 {
   Match( '(' );
   MatchKeyword( K_POLYGON );
   pointList( 1 );
   if ( lookahead == '(' ) IgnoreForm();        /* ignore property in polygon */
   Match( ')' );
 }

static void arc( int close )
/* if close is TRUE use border_width ( Shape ) */
 { int wid = 0;
   POINT arcxy[4];
   RECT ext;
   Match( '(' );
   MatchKeyword( K_ARC );
   pointValue( &xy[0] );
   pointValue( &xy[1] );
   pointValue( &xy[2] );
   if ( Arc_Three( xy[0], xy[1], xy[2], arcxy ) )
    { Arc_Extents( arcxy[0], arcxy[1], arcxy[2], arcxy[3], &ext );
      if ( ext.right - ext.left > WIDE || ext.bottom - ext.top > HIGH )
       { Warning( "Arc extends past sheet edge" );
       }
      else if ( arcxy[1].x - arcxy[0].x > 4096 ||
                arcxy[1].y - arcxy[0].y > 4096 )
       { Warning( "Arc radius too large" );
       }
      else
       { if ( close && border_width || !close && path_width ) wid = GR_WIDE;
         Add_Symbol_Grf( GR_ARC + wid,
                         arcxy[0], arcxy[1] , arcxy[2], arcxy[3] );
       }
    }
   else Warning( "Arc out of range" );
   Match( ')' );
 }

static void circle( int add_graphic )
/* if add_graphic add GR_CIRC to symbol */
 { POINT cxy[2];
   Match( '(' );
   MatchKeyword( K_CIRCLE );
   pointValue( &xy[0] );
   pointValue( &xy[1] );
   if ( add_graphic )
    { if ( Circle_Two( xy[0], xy[1], cxy ) )
       { if ( cxy[1].x - cxy[0].x > WIDE || cxy[1].y - cxy[0].y > HIGH )
          { Warning( "Circle extends past sheet edge" );
          }
         else Add_Symbol_Grf( GR_CIRC + ( border_width ? GR_WIDE : 0 ),
                              cxy[0], cxy[1], cxy[0], cxy[0] );
       }
      else Warning( "Circle out of range" );
    }
   if ( lookahead == '(' ) IgnoreForm();         /* ignore property in circle */
   Match( ')' );
 }

static void curve( int close )
/* if close is TRUE use border_width ( Shape ) */
 { POINT firstxy, lastxy;
   int pnts = 0;
   int wid = 0;
   Match( '(' );
   MatchKeyword( K_CURVE );
   if ( close && border_width || !close && path_width ) wid = GR_WIDE;
   while ( lookahead == '(' )
    { if ( PeekAtKeyword() == K_ARC )
       { arc( close );
         if ( pnts )
            Add_Symbol_Grf( GR_LINE + wid, lastxy, xy[0], lastxy, lastxy );
         else firstxy = xy[0];
         lastxy = xy[2];
       }
      else
       { pointValue( &xy[0] );
         if ( pnts )
            Add_Symbol_Grf( GR_LINE + wid, lastxy, xy[0], lastxy, lastxy );
         else firstxy = xy[0];
         lastxy = xy[0];
       }
      pnts = 1;
    }
   /* decide whether or not to close it off */
   if ( close && pnts && ( firstxy.x != lastxy.x || firstxy.y != lastxy.y ) )
    { Add_Symbol_Grf( GR_LINE + wid, firstxy, lastxy, firstxy, firstxy );
    }
   Match( ')' );
 }

static void openShape()
 {
   Match( '(' );
   MatchKeyword( K_OPENSHAPE );
   curve( 0 );
   if ( lookahead == '(' ) IgnoreForm();      /* ignore property in openShape */
   Match( ')' );
 }

static void Shape()
 {
   Match( '(' );
   MatchKeyword( K_SHAPE );
   curve( 1 );
   if ( lookahead == '(' ) IgnoreForm();          /* ignore property in Shape */
   Match( ')' );
 }

static void dot()
 {
   Match( '(' );
   MatchKeyword( K_DOT );
   pointValue( &xy[0] );
   if ( lookahead == '(' ) IgnoreForm();            /* ignore property in dot */
   Match( ')' );
 }

void rectangle( int add_graphic )
/* if add_graphic add GR_RECT to symbol */
 {
   Match( '(' );
   MatchKeyword( K_RECTANGLE );
   pointValue( &xy[0] );
   pointValue( &xy[1] );
   if ( add_graphic )
    { Add_Symbol_Grf( GR_RECT + ( border_width ? GR_WIDE : 0 ),
                      xy[0], xy[1], xy[0], xy[0] );
    }
   if ( lookahead == '(' ) IgnoreForm();      /* ignore property in rectanlge */
   Match( ')' );
 }

static int pathWidth()
/* perform coordinate mapping  */
 { long wid;
   Match( '(' );
   MatchKeyword( K_PATHWIDTH );
   wid = integerValue();
   SCALE_IT( wid );
   Match( ')' );
   return( (int)wid );
 }

static int borderWidth()
/* perform coordinate mapping  */
 { long wid;
   Match( '(' );
   MatchKeyword( K_BORDERWIDTH );
   wid = integerValue();
   SCALE_IT( wid );
   Match( ')' );
   return( (int)wid );
 }

static int textHeight()
/* perform coordinate mapping  */
 { long hgt;
   Match( '(' );
   MatchKeyword( K_TEXTHEIGHT );
   hgt = integerValue();
   SCALE_IT( hgt );
   Match( ')' );
   return( (int)hgt );
 }

static int visible()
 { int vis;
   Match( '(' );
   MatchKeyword( K_VISIBLE );
   vis = booleanValue();
   Match( ')' );
   return( vis );
 }

void figureGroup()
 { FIGUREDEF *def;
   Match( '(' );
   MatchKeyword( K_FIGUREGROUP );
   def = (FIGUREDEF *)nameDef( FIGURECLASS );       /* figureGroupNameDef */
   if ( def )
    { def->textHeight = font_height[0];
      def->pathWidth = 0;
      def->borderWidth = 0;
      def->visible = 1;
      while ( lookahead == '(' )
      { switch( PeekAtKeyword() )
         { case K_PATHWIDTH:
              def->pathWidth = pathWidth();
              break;
           case K_BORDERWIDTH:
              def->borderWidth = borderWidth();
              break;
           case K_TEXTHEIGHT:
              def->textHeight = textHeight();
              break;
           case K_VISIBLE:
              def->visible = visible();
              break;
           default:
              IgnoreForm();              /* ignore other forms in figureGroup */
              break;
         }
      }
    }
   else SkipRestOfForm();
   Match( ')' );
 }

void figureGroupOverride()
 { FIGUREDEF *def;
   Match( '(' );
   MatchKeyword( K_FIGUREGROUPOVERRIDE );
   def = (FIGUREDEF *)nameRef( FIGURECLASS );
   if ( def )
    { border_width = def->borderWidth;
      path_width = def->pathWidth;
      text_height = def->textHeight;
      is_visible = def->visible;
    }
   while ( lookahead == '(' )
    { switch( PeekAtKeyword() )
       { case K_PATHWIDTH:
            path_width = pathWidth();
            break;
         case K_BORDERWIDTH:
            border_width = borderWidth();
            break;
         case K_TEXTHEIGHT:
            text_height = textHeight();
            break;
         case K_VISIBLE:
            is_visible = visible();
            break;
         default:
            IgnoreForm();        /* ignore other forms in figureGroupOverride */
            break;
       }
    }
   Match( ')' );
 }

int figure( int add_graphic )
/* if add_graphic add GR_RECT to symbol */
 { FIGUREDEF *def;
   int key;
   int retn = 0;                      /* return TRUE only if we get some data */
   Match( '(' );
   MatchKeyword( K_FIGURE );
   /* this is tricky since both figureGroupOverride and nameRef can have '(' */
   key = -1;
   if ( lookahead == '(' )
    { key = PeekAtKeyword();
      if ( key == K_FIGUREGROUPOVERRIDE ) figureGroupOverride();
    }
   if ( key != K_FIGUREGROUPOVERRIDE )
    { def = (FIGUREDEF *)nameRef( FIGURECLASS );        /* figureGroupNameRef */
      if ( def )
       { path_width = def->pathWidth;
         border_width = def->borderWidth;
         text_height = def->textHeight;
         is_visible = def->visible;
       }
    }
   while ( lookahead == '(' )
    { key = PeekAtKeyword();
      switch( key )
       { case K_CIRCLE:
            circle( add_graphic );
            retn = 1;
            if ( !add_graphic )
             { /* convert circle's rectangle to a point */
               xy[0].x = ( xy[0].x + xy[1].x ) /2;
               xy[0].y = ( xy[0].y + xy[1].y ) /2;
             }
            break;
         case K_DOT:
            dot();
            retn = 1;
            break;
         case K_OPENSHAPE:
            if ( add_graphic )
             { openShape();
               retn = 1;
             }
            break;
         case K_PATH:
            if ( add_graphic )
             { path();
               retn = 1;
             }
            break;
         case K_POLYGON:
            if ( add_graphic )
             { polygon();
               retn = 1;
             }
            break;
         case K_RECTANGLE:
            retn = 1;
            rectangle( add_graphic );
            if ( !add_graphic )
             { /* convert rectangle to a point */
               xy[0].x = ( xy[0].x + xy[1].x ) /2;
               xy[0].y = ( xy[0].y + xy[1].y ) /2;
             }
            break;
         case K_SHAPE:
            if ( add_graphic )
             { Shape();
               retn = 1;
             }
            break;
         default:
            IgnoreForm();              /* ignore other figure types in figure */
            break;
       }
    }
   Match( ')' );
   return( retn );
 }
