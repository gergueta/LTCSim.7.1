/* edif.c -- High level parse for EDIF */

/* Copyright (C) 1993 -- Data I/O Corporation -- All Rights Reserved.
 *
 * This program is protected under the copyright laws as a published work.
 * It may not be copied, reproduced, further distributed, adaptations
 * made from the same, or used to prepare derivative works, without the
 * prior written consent of the Data I/O Corporation
 *
 * History:
 *    5/05/93 - Included in Version 2.5
 */

#include "stdafx.h"
#include "edifin.h"
#include "dwgctrl.h"

extern char FullFileName[];

extern char *string_value;    /* generated by typedValue */
extern int ignore_display;

long scale_num = 1, scale_denom = 1;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static void edifLevel()
 {
   Match( '(' );
   MatchKeyword( K_EDIFLEVEL );
   if ( integerToken() > 0 ) Warning( "Expecting edifLevel 0" );
   Match( ')' );
 }

static int prime_factors[] = { 2, 3, 5, 7, 11, 127 };

static void scale()
 { long x, y, z, w;
   int exp, ii, factor;
   long ScaleMantissa;
   int ScaleExponent;
   Match( '(' );
   MatchKeyword( K_SCALE );
   numberValue( &x, &y );
   numberValue( &z, &w );
   if ( unit() == C_DISTANCE )
    { /* BASIC_GRID := ScaleMantissa * 10 exp( ScaleExponent ) Meters */
      ScaleMantissa = CTL_Grid;
      if ( CTL_Metric == 1 ) ScaleExponent = -4;               /* centimeters */
      else if ( CTL_Metric == 2 ) ScaleExponent = -5;          /* millimeters */
      else                                                          /* inches */
       { ScaleExponent = -6;
         ScaleMantissa *= 254;
       }
      /* here these calculations are done without worrying about errors
         BASIC_GRID := ScaleMantissa * 10 exp( ScaleExponent ) Meters
         x * 10 exp( y ) EDIF := z * 10 exp( w ) Meters
         so the formula for symbol secondary GRIDS is:
         MINOR_GRID := EDIF * GRID * z * 10 exp ( w ) /
                 ( x * 10 exp( y + ScaleExponent ) * ScaleMantissa ) */
      scale_num = GRID * z;
      scale_denom = x * ScaleMantissa;
      exp = (int)( w - y - ScaleExponent );
      for ( ii = abs( exp ); ii > 0; ii-- )
       { if ( exp < 0 ) scale_denom *= 10;
         else scale_num *= 10;
       }
      if ( scale_num == scale_denom ) scale_num = scale_denom = 1;
      else                         /* find common denominators for 2, 3 and 5 */
       { for ( ii = sizeof(prime_factors) / sizeof(int) - 1; ii >= 0; ii-- )
          { factor = prime_factors[ii];
            while ( scale_num % factor == 0 && scale_denom % factor == 0 )
             { scale_num /= factor;
               scale_denom /= factor;
             }
          }
       }
    }
   Match( ')' );
 }

static void numberDefinition()
 {
   Match( '(' );
   MatchKeyword( K_NUMBERDEFINITION );
   while ( lookahead == '(' )
    { if ( PeekAtKeyword() == K_SCALE ) scale();
      else IgnoreForm();            /* ignore other forms in numberDefinition */
    }
   Match( ')' );
 }

static int interface_()
 { int retn = 0, gotsym = 0;
   PROPERTYDEF *prop;
   int key;
   Match( '(' );
   MatchKeyword( K_INTERFACE );
   while ( lookahead == '(' )
    { key = PeekAtKeyword();
      if ( key == K_PORT ) port();
      else if ( key == K_SYMBOL )
       { if ( gotsym )
          { Warning( "Only one symbol per interface" );
            IgnoreForm();                /* ignore extra symbols in interface */
          }
         else retn = symbol_();
         gotsym = 1;
       }
      else if ( key == K_PROPERTY )
       { prop = property( INTERFACE_PROPERTYCLASS );
         if ( prop && prop->type == K_STRING && prop->kind && string_value )
            Add_Attrib( prop->num, string_value );
       }
      else if ( key == K_DESIGNATOR )
       { char *str;
         str = designator();
         if ( *str )                   /* allow default reference designators */
            Add_Attrib( (BYTE)REFNAME, str );
       }
      else IgnoreForm();                   /* ignore other forms in interface */
    }
   Match( ')' );
   return( retn );
 }

static int viewType()
 { int type;
   Match( '(' );
   MatchKeyword( K_VIEWTYPE );
   type = MatchConstant();
   Match( ')' );
   return( type );
 }

static int view()
 { int retn = 0;
   int type;
   Match( '(' );
   MatchKeyword( K_VIEW );
   nameDef( 0 );       /* viewNameDef */
   type = viewType();
   if ( type == C_SCHEMATIC || type == C_GRAPHIC )
    { if ( type == C_GRAPHIC ) Set_Symbol_Type( SY_GRAPHIC );
      retn = interface_();
      while ( lookahead != ')' ) IgnoreForm();         /* ignore rest of view */
    }
   else SkipRestOfForm();                                 /* invalid viewType */
   Match( ')' );
   return( retn );
 }

static int cellType()
 { int retn;
   Match( '(' );
   MatchKeyword( K_CELLTYPE );
   retn = MatchConstant();
   Match( ')' );
   return( retn );
 }

static void cell()
 { DEF *def;
   PROPERTYDEF *prop;
   int done = 0;
   int key;
   int type;
   POINT xy;
   Match( '(' );
   MatchKeyword( K_CELL );
   def = nameDef( CELLCLASS );       /* cellNameDef */
   if ( cellType() == C_GENERIC )
    { type = SY_BLOCK;
      SymbolInit( type );
      xy.x = xy.y = 0;               /* origin is always zero for saved files */
      Set_Origin( xy );
      while ( lookahead == '(' )
       { key = PeekAtKeyword();
         if ( key == K_VIEW && !done ) done = view();
         else if ( key == K_PROPERTY )
          { prop = property( CELL_PROPERTYCLASS );
            if ( prop && prop->kind == 1 && string_value )
             { if ( !stricmp( "COMP", string_value ) )
                  Set_Symbol_Type( SY_COMP );
               else if ( !stricmp( "GATE", string_value ) )
                  Set_Symbol_Type( SY_GATE );
               else if ( !stricmp( "CELL", string_value ) )
                  Set_Symbol_Type( SY_CELL );
               else if ( !stricmp( "BLOCK", string_value ) )
                  Set_Symbol_Type( SY_BLOCK );
               else if ( !stricmp( "GRAPHIC", string_value ) )
                  Set_Symbol_Type( SY_GRAPHIC );
               else if ( !stricmp( "PIN", string_value ) )
                  Set_Symbol_Type( SY_PIN );
               else if ( !stricmp( "MASTER", string_value ) )
                  Set_Symbol_Type( SY_MASTER );
               else if ( !stricmp( "RIPPER", string_value ) )
                  Set_Symbol_Type( SY_RIPPER );
             }
          }
         else IgnoreForm();                     /* ignore other forms in cell */
       }
      if ( done )
       { /* KLUDGE, rewrite this whole section to create valid file names */
         if ( *def->name == '$' ) strcpy( FullFileName, def->name+1 );
         else strcpy( FullFileName, def->name );
         AddExt( FullFileName, ".sym" );
         strlwr( FullFileName );             /* should make a valid file name */
         SymbolSave( FullFileName );
       }
      FreeSymbol();
      /* Should free all defs which are no longer applicable at this point? */
    }
   else SkipRestOfForm();
   Match( ')' );
 }

static void technology()
 {
   Match( '(' );
   MatchKeyword( K_TECHNOLOGY );
   numberDefinition();
   while ( lookahead == '(' )
    { if ( PeekAtKeyword() == K_FIGUREGROUP ) figureGroup();
      else IgnoreForm();                  /* ignore other forms in technology */
    }
   Match( ')' );
 }

static void library()
 {
   Match( '(' );
   MatchKeyword( K_LIBRARY );
   nameDef( 0 );       /* libraryNameDef */
   edifLevel();
   technology();
   while ( lookahead == '(' )
    { if ( PeekAtKeyword() == K_CELL ) cell();
      else IgnoreForm();                     /* ignore other forms in library */
    }
   Match( ')' );
 }

static void edifVersion()
 {
   Match( '(' );
   MatchKeyword( K_EDIFVERSION );
   if ( integerToken() > 2 ) Warning( "Newer edifVersion" );
   integerToken();
   integerToken();
   Match( ')' );
 }

static void keywordMap()
 {
   Match( '(' );
   MatchKeyword( K_KEYWORDMAP );
   Match( '(' );
   MatchKeyword( K_KEYWORDLEVEL );
   if ( integerToken() > 0 ) Warning( "Expecting keyWordLevel 0" );
   Match( ')' );
   while ( lookahead != ')' ) IgnoreForm();      /* ignore rest of keywordMap */
   Match( ')' );
 }

static void edif()
 {
   Match( '(' );
   MatchKeyword( K_EDIF );
   nameDef( 0 );        /* edifFileNameDef */
   edifVersion();
   edifLevel();
   keywordMap();

   while ( lookahead == '(' )
    { if ( PeekAtKeyword() == K_LIBRARY ) library();
      else IgnoreForm();                        /* ignore other forms in edif */
    }
   Match( ')' );
 }

int unit()
 { int ii = 0;
   Match( '(' );
   MatchKeyword( K_UNIT );
   ii = MatchConstant();
   Match( ')' );
   return( ii );
 }

void Start()
 { /* initialize all variables in case we are restarting */
   ignore_display = 0;
   scale_num = scale_denom = 1;
   edif();
   Free_Names();
 }
