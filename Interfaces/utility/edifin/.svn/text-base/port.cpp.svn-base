/* port.c -- Mid level parse for EDIF */

/* Copyright (C) 1993 -- Data I/O Corporation -- All Rights Reserved.
 *
 * This program is protected under the copyright laws as a published work.
 * It may not be copied, reproduced, further distributed, adaptations
 * made from the same, or used to prepare derivative works, without the
 * prior written consent of the Data I/O Corporation
 *
 * History:
 *    5/05/93 - Included in Version 2.5
 */

#include "stdafx.h"
#include "edifin.h"

extern POINT xy[];            /* generated by figure */
extern POINT TXxy;            /* generated by display */
extern BYTE font_jus_rot;
extern char *string_value;    /* generated by typedValue */
extern int text_height;       /* generated by display in figureGroup */

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/* supplemental functions (not in sympi.h) */
void Delete_Pin( PN_PTR pn );

static PORTDEF* portNameRef()
 { PORTDEF *def = (PORTDEF *)NULL;
   if ( lookahead == '(' && PeekAtKeyword() == K_MEMBER )
    { IgnoreForm();   /* should call member();   ignore member in portNameRef */
      Warning( "Can not handle arrays of ports" );
    }
   else def = (PORTDEF *)nameRef( PORTCLASS );
   return( def );
 }

static PORTDEF* portRef()
 { PORTDEF *def;
   Match( '(' );
   MatchKeyword( K_PORTREF );
   def = portNameRef();
   if ( lookahead != '(' )
    { Warning( "Ignoring rest of portRef" );
      IgnoreForm();                                /* ignore portRefs for now */
    }
   Match( ')' );
   return( def );
 }

static PORTDEF* portNameDef()
 { PORTDEF *def = (PORTDEF *)NULL;
   if ( lookahead == '(' && PeekAtKeyword() == K_ARRAY )
    { def = (PORTDEF *)array( PORTCLASS );
    }
   else def = (PORTDEF *)nameDef( PORTCLASS );
   return( def );
 }

static int connectLocation()
 { int ok = FALSE;                               /* return error if no figure */
   Match( '(' );
   MatchKeyword( K_CONNECTLOCATION );
   xy[0].x = xy[0].y = 0;
   while ( lookahead != ')' )
    { ok = figure( 0 );
    }
   Match( ')' );
   return( ok );
 }

static int direction()
 { int ii;
   Match( '(' );
   MatchKeyword( K_DIRECTION );
   ii = MatchConstant();
   Match( ')' );
   return( ii );
 }

static void dcMaxFanout( long* mant, long* exp )
/* can be scaled integer */
 {
   Match( '(' );
   MatchKeyword( K_DCMAXFANOUT );
   if ( lookahead == '(' && PeekAtKeyword() == K_NUMBERDISPLAY )
                                               numberDisplay( mant, exp );
   else numberValue( mant, exp );
   Match( ')' );
 }

static void dcFanoutLoad( long* mant, long* exp )
/* can be scaled integer */
 {
   Match( '(' );
   MatchKeyword( K_DCFANOUTLOAD );
   if ( lookahead == '(' && PeekAtKeyword() == K_NUMBERDISPLAY )
                                               numberDisplay( mant, exp );
   else numberValue( mant, exp );
   Match( ')' );
 }

static void Add_Pin_Attr_Filtered( PN_PTR pn, unsigned char number, const char* value )
 { int skip = 0;

   if ( number == NAME )
    { /* Should check for invalid pin names here */
    }
   else if ( number == PINNUM )
    { /* Mentor puts XX for gate pins.. we must fix this */
    }
   if ( !skip ) Add_Pin_Attrib( pn, number, value );
 }

void portImplementation()
 { PORTDEF *def;
   PROPERTYDEF *prop;
   int key, gotloc;
   POINT PNxy, OFFSETxy;
   BYTE fjr = 0;
   int nameloc = 0;
   int len, h_jus, v_jus, xoffs, yoffs, font;
   PNxy.x = PNxy.y = -1;    /* force error if no connectLocation */
   Match( '(' );
   MatchKeyword( K_PORTIMPLEMENTATION );
   font_jus_rot = 0xff;                   /* so we can check for name display */
   if ( lookahead == '(' && PeekAtKeyword() == K_PORTREF ) def = portRef();
   else def = portNameRef();
   if ( font_jus_rot != 0xff )         /* had a display inside name construct */
    { fjr = font_jus_rot;
      OFFSETxy = TXxy;
    }
   while ( lookahead == '(' )
    { key = PeekAtKeyword();
      if ( !def || !def->pn ) IgnoreForm();      /* ignore portImplementation */
      else if ( key == K_CONNECTLOCATION )
       { gotloc = connectLocation();
         PNxy = xy[0];     /* set by connectLocation */
       }
      else if ( key == K_FIGURE )
       { figure( 1 );    /* add the figures in portImplementation as graphics */
       }
      else if ( key == K_KEYWORDDISPLAY )
       { if ( keywordDisplay() == K_DESIGNATOR )
          {
          }
       }
      else if ( key == K_PROPERTYDISPLAY )
       { prop = propertyDisplay( PORT_PROPERTYCLASS );
         if ( prop && prop->type == K_STRING && prop->num == NAME )
          { fjr = font_jus_rot;
            OFFSETxy = TXxy;
          }
       }
      else if ( key == K_PROPERTY )
       { prop = property( PORT_PROPERTYCLASS );
         if ( prop && prop->type == K_STRING && prop->kind && string_value )
          { Add_Pin_Attr_Filtered( def->pn, prop->num, string_value );
          }
       }
      else IgnoreForm();          /* ignore other forms in portImplementation */
    }
   if ( def && def->pn )
    {
      /* first figure out which way they want the text to be positioned
         and then set the justification based on that */
      /* we don't know the text width but we do know the text_height */
      /* convert everything to CENTERCENTER */
      h_jus = 1 - (int)( ( fjr & 0x0f ) - 1 ) % 3;
                                                /* 1 = lft, 0 = mid, -1 = rgt */
      v_jus = 1 - (int)( 9 - ( fjr & 0x0f ) ) / 3;
                                                /* 1 = top, 0 = mid, -1 = bot */
      len = strlen( def->name );
      if ( fjr & 0x10 )
       { OFFSETxy.x += text_height * v_jus / 2;
         OFFSETxy.y -= text_height * len * h_jus / 2;
       }
      else
       { OFFSETxy.x += text_height * len * h_jus / 2;
         OFFSETxy.y += text_height * v_jus / 2;
       }
      /* now OFFSETxy is the origin of name if just = CENTERCENTER */
      xoffs = OFFSETxy.x - PNxy.x;
      yoffs = OFFSETxy.y - PNxy.y;
      font = fjr >> 5;
      if ( fjr & 0x10 )                                       /* rotated text */
       { if ( abs( yoffs ) > abs( xoffs ) )              /* use Left or Right */
          { if ( yoffs > 0 )
             { fjr = 0x16;    /* Right */
               OFFSETxy.y -= text_height * len / 2;  /* convert back to Right */
               nameloc = OFFSETxy.y - PNxy.y;
             }
            else
             { fjr = 0x14;    /* Left */
               OFFSETxy.y += text_height * len / 2;   /* convert back to Left */
               nameloc = PNxy.y - OFFSETxy.y;
             }
          }
         else                                            /* use Top or Bottom */
          { if ( xoffs > 0 )
             { fjr = 0x18;    /* Top */
               OFFSETxy.x -= text_height / 2;          /* convert back to Top */
               nameloc = OFFSETxy.x - PNxy.x;
             }
            else
             { fjr = 0x12;    /* Bottom */
               OFFSETxy.x += text_height / 2;       /* convert back to Bottom */
               nameloc = PNxy.x - OFFSETxy.x;
             }
          }
       }
      else if ( fjr )                                               /* normal */
       { if ( abs( xoffs ) > abs( yoffs ) )              /* use Left or Right */
          { if ( xoffs > 0 )
             { fjr = 4;       /* Left */
               OFFSETxy.x -= text_height * len / 2;   /* convert back to Left */
               nameloc = OFFSETxy.x - PNxy.x;
             }
            else
             { fjr = 6;       /* Right */
               OFFSETxy.x += text_height * len / 2;  /* convert back to Right */
               nameloc = PNxy.x - OFFSETxy.x;
             }
          }
         else                                            /* use Top or Bottom */
          { if ( yoffs > 0 )
             { fjr = 8;       /* Top */
               OFFSETxy.y -= text_height / 2;          /* convert back to Top */
               nameloc = OFFSETxy.y - PNxy.y;
             }
            else
             { fjr = 2;       /* Bottom */
               OFFSETxy.y += text_height / 2;       /* convert back to Bottom */
               nameloc = PNxy.y - OFFSETxy.y;
             }
          }
       }
      fjr |= (BYTE)( font << 5 );
      if ( nameloc < 0 ) nameloc = 0;
      else if ( nameloc >= 8 * GRID ) nameloc = 8 * GRID - 1;
      if ( gotloc )
       { /* round pin to nearest grid */
         if ( PNxy.x < 0 )
            PNxy.x = ( PNxy.x - GRID/2 ) / GRID * GRID;
         else
            PNxy.x = ( PNxy.x + GRID/2 ) / GRID * GRID;
         if ( PNxy.y < 0 )
            PNxy.y = ( PNxy.y - GRID/2 ) / GRID * GRID;
         else
            PNxy.y = ( PNxy.y + GRID/2 ) / GRID * GRID;
         Set_Pin_Location( def->pn, PNxy );
         Set_Pin_Offset( def->pn, (BYTE)nameloc, fjr );
       }
      else                          /* if no connectLocation we're in trouble */
       { Delete_Pin( def->pn );
       }
    }
   Match( ')' );
 }

static int xx = 50 * GRID, yy = 50 * GRID;
void port()
 { PORTDEF* def = 0;
   PROPERTYDEF* prop;
   POINT PNxy;
   char *str, buff[80];
   int key, ii;
   long mant, exp;

   Match( '(' );
   MatchKeyword( K_PORT );
   def = portNameDef();
   /* We get pin attributes before the pin location so add the pin first. */
   xx += GRID * 2;
   if ( xx >= 100 * GRID )  /* any old method which makes unique locations */
    { xx = 50 * GRID;
      yy += GRID * 2;
      if ( yy >= 100 * GRID ) yy = 50 * GRID;
    }
   PNxy.x = -xx;      /* cheat and fake these locations */
   PNxy.y = -yy;
   if ( def )
    { def->pn = Add_Pin( PNxy, 0, 0, -1 );
      if ( def->pn )
         Add_Pin_Attr_Filtered( def->pn, NAME, def->name );
    }
   while ( lookahead == '(' )
    { key = PeekAtKeyword();
      if ( !def || !def->pn ) IgnoreForm();    /* ignore port if no valid pin */
      else if ( key == K_DESIGNATOR )
       { if ( str = designator() )
          { Add_Pin_Attrib( def->pn, PINNUM, str );
          }
       }
      else if ( key == K_DIRECTION )
       { ii = direction();
         if ( ii == C_INPUT ) str = "Input";
         else if ( ii == C_OUTPUT ) str = "Output";
         else if ( ii == C_INOUT ) str = "Bidir";
         else str = "";
          { Add_Pin_Attrib( def->pn, PINUSE, str );
          }
       }
      else if ( key == K_DCMAXFANOUT )
       { dcMaxFanout( &mant, &exp );
         if ( exp < 0 )
          { float ff;
            ff = (float)mant;
            while ( exp < 0 )
             { exp++;
               ff /= (float)10.;
             }
            sprintf( buff, "%f", ff );
          }
         else
          { while ( exp > 0 )
             { exp--;
               mant *= 10;
             }
            sprintf( buff, "%ld", mant );
          }
         Add_Pin_Attrib( def->pn, FANOUT, buff );
       }
      else if ( key == K_DCFANOUTLOAD )
       { dcFanoutLoad( &mant, &exp );
         if ( exp < 0 )
          { float ff;
            ff = (float)mant;
            while ( exp < 0 )
             { exp++;
               ff /= (float)10.;
             }
            sprintf( buff, "%f", ff );
          }
         else
          { while ( exp > 0 )
             { exp--;
               mant *= 10;
             }
            sprintf( buff, "%ld", mant );
          }
         Add_Pin_Attrib( def->pn, FANIN, buff );
       }
      else if ( key == K_PROPERTY )
       { prop = property( PORT_PROPERTYCLASS );
         if ( prop && prop->type == K_STRING && prop->kind && string_value )
          { Add_Pin_Attr_Filtered( def->pn, prop->num, string_value );
          }
       }
      else IgnoreForm();                        /* ignore other forms in port */
    }
   Match( ')' );
 }
